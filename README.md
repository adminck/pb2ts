# pb2ts

`pb2ts` 是一个强大的工具，可以将 Protocol Buffer (protobuf) 定义文件转换为 TypeScript HTTP 客户端代码。它特别适用于使用 `google.api.http` 注解来定义 RESTful API 的 gRPC 服务。

## 功能特性

- **自动代码生成**：将 `.proto` 文件自动生成为 TypeScript 客户端代码
- **HTTP 注解支持**：解析 `google.api.http` 注解以生成对应的 HTTP 请求代码
- **类型安全**：生成的 TypeScript 代码包含完整的类型定义
- **服务和函数两种模式**：可选择生成服务类或纯函数
- **高度可配置**：支持自定义模板和输出选项
- **支持嵌套消息和枚举**：完整处理复杂的 protobuf 结构
- **完整的 Protobuf 类型映射**：支持基本类型、消息、枚举、Map 类型和重复字段
- **注释保留**：保留原始 proto 文件中的注释信息
- **Go 语言解析器**：使用高性能 Go 语言解析器处理 proto 文件

## 安装

```bash
npm install pb2ts
```

## 快速开始

### 1. 基本用法

```bash
# 使用 CLI 生成 TypeScript 代码
npx pb2ts gen --proto ./proto --out ./src/api
```

### 2. 配置文件

创建 `pb2ts.config.ts` 配置文件：

**注意**：默认配置使用原生 `fetch` API。如需使用 `axios` 或其他 HTTP 库，需要自定义 `methodWrapper`。

```ts
import { defineConfig } from 'pb2ts'

export default defineConfig({
  proto: {
    root: './',
    include: [],
    exclude: ['node_modules', 'dist']
  },
  output: {
    dir: './api',
    generationType: 'service', // 'service' 或 'function'
    // 默认使用 fetch，如需使用 axios 请配置 serviceTemplate.methodWrapper
    serviceTemplate: {
      classWrapper: (serviceName, methodsCode) => `
class ${serviceName}Service {
  private baseUrl: string;

  constructor(baseUrl: string = '') {
    this.baseUrl = baseUrl;
  }

${methodsCode}
}`,
      methodWrapper: (rpc) => `
  async ${rpc.name}(request: Types.${rpc.request}): Promise<Types.${rpc.resp}> {
    const response = await fetch(\`\${this.baseUrl}${rpc.path}\`, {
      method: '${rpc.method.toUpperCase()}',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(\`${rpc.name} failed: \${response.statusText}\`);
    }

    return response.json();
  }`
    }
  }
})
```

**使用 axios 的示例**：

```ts
import { defineConfig } from 'pb2ts'

export default defineConfig({
  proto: {
    root: './',
    include: [],
    exclude: ['node_modules', 'dist']
  },
  output: {
    dir: './api',
    imports: [
      'import axios from \'axios\'',
      'import type { AxiosResponse } from \'axios\''
    ],
    serviceTemplate: {
      classWrapper: (serviceName, methodsCode) => `
class ${serviceName}Service {
  private axiosInstance: any;

  constructor(baseURL: string = '') {
    this.axiosInstance = axios.create({ baseURL });
  }

${methodsCode}
}`,
      methodWrapper: (rpc) => `
  async ${rpc.name}(request: Types.${rpc.request}): Promise<Types.${rpc.resp}> {
    const { path, method } = rpc;
    const response = await this.axiosInstance[method.toLowerCase()](path, request);
    return response.data;
  }`
    }
  }
})
```

### 3. 使用示例

假设你有一个 `.proto` 文件：

```protobuf
syntax = "proto3";

import "google/api/annotations.proto";

package example;

message GetUserRequest {
  string user_id = 1;
}

message User {
  string id = 1;
  string name = 2;
}

service UserService {
  rpc GetUser(GetUserRequest) returns (User) {
    option (google.api.http) = {
      get: "/v1/users/{user_id}"
    };
  }
}
```

执行 `pb2ts gen` 后会生成类似以下的 TypeScript 代码（使用默认 fetch 配置）：

```ts
// ./api/UserService/UserService.types.ts
/**
 * ⚠️ AUTO-GENERATED CODE - DO NOT EDIT
 *
 * This file is automatically generated from Protocol Buffer definitions.
 * Any manual changes will be overwritten on the next generation.
 *
 * Generated at: 2023-01-01T00:00:00.000Z
 */

export interface GetUserRequest {
  user_id: string;
}

export interface User {
  id: string;
  name: string;
}

// ./api/UserService/UserService.index.ts
/**
 * ⚠️ AUTO-GENERATED CODE - DO NOT EDIT
 *
 * This file is automatically generated from Protocol Buffer definitions.
 * Any manual changes will be overwritten on the next generation.
 *
 * Generated at: 2023-01-01T00:00:00.000Z
 */
import * as Types from './UserService.types';

export { Types };

/**
 * Service class for UserService
 */
export class UserServiceService {
  private baseUrl: string;

  constructor(baseUrl: string = '') {
    this.baseUrl = baseUrl;
  }

  async GetUser(request: Types.GetUserRequest): Promise<Types.User> {
    const response = await fetch(`${this.baseUrl}/v1/users/${request.user_id}`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`GetUser failed: ${response.statusText}`);
    }

    return response.json();
  }
}

export { UserServiceService };
```

**注意**：还会生成一个 `UserService.extensions.ts` 文件，用于用户自定义扩展，该文件在首次生成后不会被覆盖。

## 配置选项

### Proto 配置

- `root`: proto 文件根目录 (默认: "./")
- `include`: 包含的文件模式 (默认: ["**/*.proto"])
- `exclude`: 排除的文件模式 (默认: ["node_modules", "dist"])

### 输出配置

- `dir`: 输出目录 (默认: "./api")
- `generationType`: 生成类型 ('service' 或 'function', 默认: 'service')
- `imports`: 额外导入语句
- `funcCalls`: 为特定 RPC 方法自定义调用模板
- `serviceTemplate`: 服务类模板配置
  - `classWrapper`: 类包装函数
  - `methodWrapper`: 方法包装函数
  - `extensionWrapper`: 扩展文件模板
- `functionTemplate`: 函数生成模板配置
  - `functionWrapper`: 函数包装函数

## 支持的 Protobuf 特性

- 消息定义 (Messages)
- 枚举定义 (Enums)
- 嵌套消息和枚举
- Map 类型
- Repeated 字段
- `google.api.http` 注解 (GET, POST, PUT, DELETE, PATCH)
- 基本类型映射 (int32, string, bool, bytes 等)
- 注释保留

## 项目架构

### 技术栈

- **Go 语言解析器**: `go_pb_parser` - 高性能的 Protocol Buffer 解析器
- **TypeScript 生成器**: `packages/pb2ts` - 代码生成和 CLI 工具
- **构建工具**: pnpm, tsup
- **命令行框架**: cac

### 项目结构

```
pb2ts/
├── go_pb_parser/              # Go 语言解析器
│   ├── cmd/                   # 命令行入口
│   ├── internal/
│   │   ├── parser/           # 解析器核心逻辑
│   │   └── types/            # 类型定义
│   └── test_proto/           # 测试 proto 文件
├── packages/pb2ts/            # TypeScript 包
│   ├── src/
│   │   ├── cli/              # 命令行界面
│   │   ├── config/           # 配置系统
│   │   ├── generator/        # 代码生成器
│   │   └── parser/           # 解析器接口
├── bin/                      # 编译后的二进制文件
├── scripts/                  # 构建脚本
└── test/                     # 测试文件
```

### Go 解析器

Go 解析器负责解析 `.proto` 文件并提取服务定义、消息、枚举等信息。它使用 `github.com/jhump/protoreflect` 库来处理复杂的 Protocol Buffer 文件，并生成 JSON 格式的解析结果供 TypeScript 代码生成器使用。

### TypeScript 生成器

TypeScript 生成器接收来自 Go 解析器的数据，并根据配置生成相应的 TypeScript 代码。它支持两种生成模式：
- **服务模式**: 生成带有静态方法的服务类
- **函数模式**: 生成独立的函数

## 开发

### 先决条件

- Node.js >= 18
- pnpm
- Go >= 1.19

### 构建

```bash
# 安装依赖
pnpm install

# 构建 Go 解析器
go build -o bin/pb2ts-parser ./go_pb_parser/cmd/main.go

# 构建 TypeScript 包
pnpm run build

# 开发模式
pnpm run dev
```

### 测试

```bash
# 运行 Go 单元测试
cd go_pb_parser && go test ./...

# 运行代码生成测试
pnpm run test:gen
```

### 贡献

我们欢迎社区贡献！请遵循以下步骤：

1. Fork 项目
2. 创建功能分支 (`git checkout -b feature/AmazingFeature`)
3. 提交更改 (`git commit -m 'Add some AmazingFeature'`)
4. 推送到分支 (`git push origin feature/AmazingFeature`)
5. 创建 Pull Request

## 常见问题

### Q: 如何自定义生成的代码模板？

A: 通过在配置文件中定义 `serviceTemplate` 或 `functionTemplate` 来自定义代码模板。

### Q: 支持哪些 HTTP 方法？

A: 支持 GET, POST, PUT, DELETE, PATCH 等所有 `google.api.http` 注解定义的方法。

### Q: 如何处理嵌套的消息类型？

A: 生成器会自动处理嵌套消息类型并在类型文件中正确声明它们。

## 许可证

MulanPSL2 (木兰宽松许可证 v2)