import type { Service,ParseResult,Enum,Message,Field,RPC } from '../parser/types'
import type { Pb2tsConfig } from '../config/types'
import path from 'path'
import fs from 'fs'

// 通用的驼峰转换函数
function toCamelCase(str: string): string {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

// 通用的注释格式化函数
function formatComment(comment: string, indent: number = 0): string {
    const indentStr = ' '.repeat(indent);
    const lines = comment.trim().split('\n');

    if (lines.length === 1) {
        return `${indentStr}/** ${lines[0]} */`;
    }

    return [
        `${indentStr}/**`,
        ...lines.map(line => `${indentStr} * ${line}`),
        `${indentStr} */`
    ].join('\n');
}

// 通用的头部注释生成函数
function generateHeader(): string {
    return `/**
 * ⚠️ AUTO-GENERATED CODE - DO NOT EDIT
 * 
 * This file is automatically generated from Protocol Buffer definitions.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Generated at: ${new Date().toISOString()}
 */`;
}

// 通用的文件写入函数
function writeFile(filePath: string, content: string): void {
    fs.writeFileSync(filePath, content, 'utf-8');
    console.log(`✅ Generated: ${filePath}`);
}

// 通用的目录创建函数
function ensureDir(dir: string): void {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
}

// ===== 核心生成器类 =====
export class ProtoToTsGenerator {
    private config: Pb2tsConfig;
    private generateServiceContent: (service: Service) => string;

    constructor(config: Pb2tsConfig) {
        this.config = config;
        
        // 根据配置预先生成对应的服务内容生成函数
        if (config.output.generationType === 'function') {
            this.generateServiceContent = (service: Service): string => {
                const parts: string[] = [];
                for (const rpc of service.rpc) {
                    let templateFn = this.config.output.functionTemplate!.functionWrapper!;
                    if (this.config.output.funcCalls && this.config.output.funcCalls[rpc.name]) {
                        templateFn =  this.config.output.funcCalls![rpc.name];
                    }
                    parts.push(templateFn(rpc));
                    parts.push('');
                }
                return parts.join('');
            };
        } else {
            this.generateServiceContent = (service: Service): string => {
                // 获取方法代码
                const methodsCode = service.rpc.map(rpc => {
                   const templateFn = this.config.output.serviceTemplate!.methodWrapper!;
                   if (this.config.output.funcCalls && this.config.output.funcCalls[rpc.name]) {
                       return this.config.output.funcCalls![rpc.name](rpc);
                   }
                   return templateFn(rpc);
                }).join('\n\n');
                
                // 使用配置中的模板函数（在loadConfig阶段已确保存在）
                const templateFn = this.config.output.serviceTemplate!.classWrapper!;
                return templateFn(service.name, methodsCode);
            };
        }
    }

    /**
     * 生成所有服务的代码
     */
    generate(services: ParseResult): void {
        for (const service of services) {
            console.log(`Generating ${service.name}...`);
            if (service.rpc.length === 0) {
                console.log(`${service.name} has no RPC methods, skipping...`);
                continue;
            }
            this.generateService(service);
        }
    }

    /**
     * 为单个服务生成代码
     */
    private generateService(service: Service): void {
        const serviceDir = path.join(this.config.output.dir, service.name);

        // 确保目录存在
        ensureDir(serviceDir);

        // 1. 生成 types.ts（完全覆盖）
        const typesContent = this.generateTypes(service);
        writeFile(
            path.join(serviceDir, `${service.name}.types.ts`),
            typesContent
        );

        // 2. 生成 index.ts（完全覆盖）
        const indexContent = this.generateIndex(service);
        writeFile(
            path.join(serviceDir, `${service.name}.index.ts`),
            indexContent
        );

        // 3. 初始化用户扩展文件（仅创建，不覆盖）
        this.initializeCustomFile(service, serviceDir);
    }

    /**
     * 生成 types.ts 内容
     */
    private generateTypes(service: Service): string {
        const parts: string[] = [];

        // 文件头部警告
        parts.push(generateHeader());

        // 生成 Enums
        for (const enumDef of service.enums) {
            // 生成 Enum - 内联实现
            const enumParts: string[] = [];
            if (enumDef.leadingComments) {
                enumParts.push(formatComment(enumDef.leadingComments));
            }
            enumParts.push(`export enum ${enumDef.name} {`);
            for (const item of enumDef.enumItems) {
                if (item.leadingComments) {
                    enumParts.push(`  ${formatComment(item.leadingComments, 2)}`);
                }
                enumParts.push(`  ${item.key} = ${item.value},`);
            }
            enumParts.push('}');
            parts.push(enumParts.join('\n'));
        }

        // 生成 Messages (Interfaces)
        for (const message of service.message) {
            // 生成 Message - 内联实现
            const messageParts: string[] = [];
            if (message.leadingComments) {
                messageParts.push(formatComment(message.leadingComments));
            }
            messageParts.push(`export interface ${message.name} {`);
            for (const field of message.fields) {
                if (field.leadingComments) {
                    messageParts.push(`  ${formatComment(field.leadingComments, 2)}`);
                }
                const fieldType = this.getFieldType(field);
                messageParts.push(`  ${field.name}: ${fieldType};`);
            }
            messageParts.push('}');
            parts.push(messageParts.join('\n'));
        }

        return parts.join('\n\n');
    }

    /**
     * 生成 index.ts 内容
     */
    private generateIndex(service: Service): string {
        const parts: string[] = [];

        parts.push(generateHeader());

        // 导入类型
        parts.push(`import * as Types from './${service.name}.types';`);
        parts.push('');

        // 导入 依赖 文件
        this.config.output.imports?.forEach((importPath) => {
            parts.push(importPath);
        });

        // 导出类型
        parts.push(`export { Types };`);
        parts.push('');

        // 使用预先生成的函数直接生成内容
        parts.push(this.generateServiceContent(service));

        return parts.join('\n');
    }

    /**
     * 获取字段类型
     */
    private getFieldType(field: Field): string {
        let baseType: string;

        if (field.isMap) {
            // Map 类型
            const keyType = this.mapProtoTypeToTs(field.mapKey);
            const valueType = this.mapProtoTypeToTs(field.mapValue);
            baseType = `Record<${keyType}, ${valueType}>`;
        } else if (field.typeName) {
            // 自定义类型（Message 或 Enum）
            baseType = field.typeName;
        } else {
            // 基础类型
            baseType = this.mapProtoTypeToTs(field.type);
        }

        // 处理 repeated (数组)
        if (field.isRepeated) {
            return `${baseType}[]`;
        }

        return baseType;
    }

    /**
     * Proto 类型到 TS 类型映射
     */
    private mapProtoTypeToTs(protoType: string): string {
        const typeMap: Record<string, string> = {
            'int32': 'number',
            'int64': 'number',
            'uint32': 'number',
            'uint64': 'number',
            'sint32': 'number',
            'sint64': 'number',
            'fixed32': 'number',
            'fixed64': 'number',
            'sfixed32': 'number',
            'sfixed64': 'number',
            'float': 'number',
            'double': 'number',
            'bool': 'boolean',
            'string': 'string',
            'bytes': 'Uint8Array',
        };

        return typeMap[protoType] || protoType;
    }

    /**
     * 初始化用户自定义文件（仅在不存在时创建）
     */
    private initializeCustomFile(service: Service,serviceDir:string): void {
        const customFilePath = path.join(serviceDir, `${service.name}.extensions.ts`);
        // 只在文件不存在时创建
        if (!fs.existsSync(customFilePath)) {
            const templateFn = this.config.output.serviceTemplate?.extensionWrapper!;
            const template = templateFn(service.name);
            writeFile(customFilePath, template);
        }
    }
}