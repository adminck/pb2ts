import type { Service,ParseResult,Enum,Message,Field,RPC } from '../parser/types'
import type { Pb2tsConfig } from '../config/types'
import path from 'path'
import fs from 'fs'

// ===== 代码生成器配置 =====
interface GeneratorConfig {
    outputDir: string;
    customDir?: string; // 用户自定义代码目录
}

// ===== 核心生成器类 =====
export class ProtoToTsGenerator {
    private config: Pb2tsConfig;
    private generatorConfig: GeneratorConfig;

    constructor(config: Pb2tsConfig) {
        this.config = config;
        this.generatorConfig = {
            outputDir: path.join(config.output.dir, 'generated'),
        };
    }

    /**
     * 生成所有服务的代码
     */
    generate(services: ParseResult): void {
        for (const service of services) {
            console.log(`Generating ${service.name}...`);
            if (service.rpc.length === 0) {
                console.log(`${service.name} has no RPC methods, skipping...`);
                continue;
            }
            this.generateService(service);
        }
    }

    /**
     * 为单个服务生成代码
     */
    private generateService(service: Service): void {
        const serviceDir = path.join(this.generatorConfig.outputDir,service.name);

        // 确保目录存在
        this.ensureDir(serviceDir);

        // 1. 生成 types.ts（完全覆盖）
        const typesContent = this.generateTypes(service);
        this.writeFile(
            path.join(serviceDir, `${service.name}.types.ts`),
            typesContent
        );

        // 2. 生成 index.ts（完全覆盖）
        const indexContent = this.generateIndex(service);
        this.writeFile(
            path.join(serviceDir, `${service.name}.index.ts`),
            indexContent
        );

        // 3. 初始化用户扩展文件（仅创建，不覆盖）
        this.initializeCustomFile(service,serviceDir);
    }

    /**
     * 生成 types.ts 内容
     */
    private generateTypes(service: Service): string {
        const parts: string[] = [];

        // 文件头部警告
        parts.push(this.generateHeader());

        // 生成 Enums
        for (const enumDef of service.enums) {
            parts.push(this.generateEnum(enumDef));
        }

        // 生成 Messages (Interfaces)
        for (const message of service.message) {
            parts.push(this.generateMessage(message));
        }

        return parts.join('\n\n');
    }

    /**
     * 生成 index.ts 内容
     */
    private generateIndex(service: Service): string {
        const parts: string[] = [];

        parts.push(this.generateHeader());

        // 导入类型
        parts.push(`import * as Types from './${service.name}.types';`);
        parts.push('');

        // 导出类型
        parts.push(`export { Types };`);
        parts.push('');

        // 生成服务类
        parts.push(this.generateServiceClass(service));

        return parts.join('\n');
    }

    /**
     * 生成文件头部注释
     */
    private generateHeader(): string {
        return `/**
 * ⚠️ AUTO-GENERATED CODE - DO NOT EDIT
 * 
 * This file is automatically generated from Protocol Buffer definitions.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Generated at: ${new Date().toISOString()}
 */`;
    }

    /**
     * 生成 Enum
     */
    private generateEnum(enumDef: Enum): string {
        const parts: string[] = [];

        // 添加注释
        if (enumDef.leadingComments) {
            parts.push(this.formatComment(enumDef.leadingComments));
        }

        parts.push(`export enum ${enumDef.name} {`);

        for (const item of enumDef.enumItems) {
            if (item.leadingComments) {
                parts.push(`  ${this.formatComment(item.leadingComments, 2)}`);
            }
            parts.push(`  ${item.key} = ${item.value},`);
        }

        parts.push('}');

        return parts.join('\n');
    }

    /**
     * 生成 Message (Interface)
     */
    private generateMessage(message: Message): string {
        const parts: string[] = [];

        // 添加注释
        if (message.leadingComments) {
            parts.push(this.formatComment(message.leadingComments));
        }

        parts.push(`export interface ${message.name} {`);

        for (const field of message.fields) {
            if (field.leadingComments) {
                parts.push(`  ${this.formatComment(field.leadingComments, 2)}`);
            }

            const fieldType = this.getFieldType(field);
            parts.push(`  ${field.name}: ${fieldType};`);
        }

        parts.push('}');

        return parts.join('\n');
    }

    /**
     * 获取字段类型
     */
    private getFieldType(field: Field): string {
        let baseType: string;

        if (field.isMap) {
            // Map 类型
            const keyType = this.mapProtoTypeToTs(field.mapKey);
            const valueType = this.mapProtoTypeToTs(field.mapValue);
            baseType = `Record<${keyType}, ${valueType}>`;
        } else if (field.typeName) {
            // 自定义类型（Message 或 Enum）
            baseType = field.typeName;
        } else {
            // 基础类型
            baseType = this.mapProtoTypeToTs(field.type);
        }

        // 处理 repeated (数组)
        if (field.isRepeated) {
            return `${baseType}[]`;
        }

        return baseType;
    }

    /**
     * Proto 类型到 TS 类型映射
     */
    private mapProtoTypeToTs(protoType: string): string {
        const typeMap: Record<string, string> = {
            'int32': 'number',
            'int64': 'number',
            'uint32': 'number',
            'uint64': 'number',
            'sint32': 'number',
            'sint64': 'number',
            'fixed32': 'number',
            'fixed64': 'number',
            'sfixed32': 'number',
            'sfixed64': 'number',
            'float': 'number',
            'double': 'number',
            'bool': 'boolean',
            'string': 'string',
            'bytes': 'Uint8Array',
        };

        return typeMap[protoType] || protoType;
    }

    /**
     * 生成服务类
     */
    private generateServiceClass(service: Service): string {
        const parts: string[] = [];

        if (service.leadingComments) {
            parts.push(this.formatComment(service.leadingComments));
        }

        parts.push(`export class ${service.name}Service {`);
        parts.push('  private baseUrl: string;');
        parts.push('');
        parts.push('  constructor(baseUrl: string) {');
        parts.push('    this.baseUrl = baseUrl;');
        parts.push('  }');

        // 生成 RPC 方法
        for (const rpc of service.rpc) {
            parts.push('');
            parts.push(this.generateRpcMethod(rpc));
        }

        parts.push('}');

        return parts.join('\n');
    }

    /**
     * 生成 RPC 方法
     */
    private generateRpcMethod(rpc: RPC): string {
        const parts: string[] = [];

        if (rpc.leadingComments) {
            parts.push(`  ${this.formatComment(rpc.leadingComments, 2)}`);
        }

        const methodName = this.toCamelCase(rpc.name);
        parts.push(`  async ${methodName}(request: Types.${rpc.request}): Promise<Types.${rpc.resp}> {`);
        parts.push(`    const response = await fetch(\`\${this.baseUrl}${rpc.path}\`, {`);
        parts.push(`      method: '${rpc.method.toUpperCase()}',`);
        parts.push(`      headers: { 'Content-Type': 'application/json' },`);
        parts.push(`      body: JSON.stringify(request),`);
        parts.push(`    });`);
        parts.push('');
        parts.push('    if (!response.ok) {');
        parts.push(`      throw new Error(\`${rpc.name} failed: \${response.statusText}\`);`);
        parts.push('    }');
        parts.push('');
        parts.push('    return response.json();');
        parts.push('  }');

        return parts.join('\n');
    }

    /**
     * 格式化注释
     */
    private formatComment(comment: string, indent: number = 0): string {
        const indentStr = ' '.repeat(indent);
        const lines = comment.trim().split('\n');

        if (lines.length === 1) {
            return `${indentStr}/** ${lines[0]} */`;
        }

        return [
            `${indentStr}/**`,
            ...lines.map(line => `${indentStr} * ${line}`),
            `${indentStr} */`
        ].join('\n');
    }

    /**
     * 转换为驼峰命名
     */
    private toCamelCase(str: string): string {
        return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    }

    /**
     * 初始化用户自定义文件（仅在不存在时创建）
     */
    private initializeCustomFile(service: Service,serviceDir:string): void {
        const customFilePath = path.join(serviceDir, `${service.name}.extensions.ts`);
        // 只在文件不存在时创建
        if (!fs.existsSync(customFilePath)) {
            const template = this.generateExtensionTemplate(service);
            this.writeFile(customFilePath, template);
        }
    }

    /**
     * 生成扩展文件模板
     */
    private generateExtensionTemplate(service: Service): string {
        return `/**
 * User custom extensions for ${service.name}
 * 
 * This file is for your custom code and will NOT be overwritten.
 * Import generated types from: ../${service.name}/${service.name}.types
 */

import { ${service.name}Service, Types } from '../generated/${service.name}/${service.name}.index';

// Example: Extend the generated service
export class ${service.name}ServiceExtended extends ${service.name}Service {
  // Add your custom methods here
  
  // Example:
  // async customMethod(data: Types.SomeMessage): Promise<void> {
  //   // Your custom logic
  // }
}

// Example: Helper functions
// export function validate${service.name}(data: Types.SomeMessage): boolean {
//   // Your validation logic
//   return true;
// }
`;
    }

    /**
     * 确保目录存在
     */
    private ensureDir(dir: string): void {
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
    }

    /**
     * 写入文件
     */
    private writeFile(filePath: string, content: string): void {
        fs.writeFileSync(filePath, content, 'utf-8');
        console.log(`✅ Generated: ${filePath}`);
    }
}
