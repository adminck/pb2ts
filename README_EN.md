# pb2ts

`pb2ts` is a powerful tool that converts Protocol Buffer (protobuf) definition files into TypeScript HTTP client code. It's especially suitable for gRPC services that use `google.api.http` annotations to define RESTful APIs.

## Features

- **Automatic Code Generation**: Convert `.proto` files into TypeScript client code automatically
- **HTTP Annotation Support**: Parse `google.api.http` annotations to generate corresponding HTTP request code
- **Type Safety**: Generated TypeScript code includes complete type definitions
- **Dual Modes**: Choose between generating service classes or pure functions
- **Highly Configurable**: Supports custom templates and output options
- **Support for Nested Messages and Enums**: Fully handles complex protobuf structures
- **Complete Protobuf Type Mapping**: Supports basic types, messages, enums, Map types, and repeated fields
- **Comment Preservation**: Preserves comment information from original proto files
- **Go Language Parser**: Uses high-performance Go language parser to process proto files

## Installation

```bash
npm install pb2ts
```

## Quick Start

### 1. Basic Usage

```bash
# Use CLI to generate TypeScript code
npx pb2ts gen --proto ./proto --out ./src/api
```

### 2. Configuration File

Create a `pb2ts.config.ts` configuration file:

**Note**: The default configuration uses the native `fetch` API. To use `axios` or other HTTP libraries, you need to customize the `methodWrapper`.

```ts
import { defineConfig } from 'pb2ts'

export default defineConfig({
  proto: {
    root: './',
    include: [],
    exclude: ['node_modules', 'dist']
  },
  output: {
    dir: './api',
    generationType: 'service', // 'service' or 'function'
    // Default uses fetch, configure serviceTemplate.methodWrapper to use axios
    serviceTemplate: {
      classWrapper: (serviceName, methodsCode) => `
class ${serviceName}Service {
  private baseUrl: string;

  constructor(baseUrl: string = '') {
    this.baseUrl = baseUrl;
  }

${methodsCode}
}`,
      methodWrapper: (rpc) => `
  async ${rpc.name}(request: Types.${rpc.request}): Promise<Types.${rpc.resp}> {
    const response = await fetch(\`\${this.baseUrl}${rpc.path}\`, {
      method: '${rpc.method.toUpperCase()}',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(\`${rpc.name} failed: \${response.statusText}\`);
    }

    return response.json();
  }`
    }
  }
})
```

**Example using axios**:

```ts
import { defineConfig } from 'pb2ts'

export default defineConfig({
  proto: {
    root: './',
    include: [],
    exclude: ['node_modules', 'dist']
  },
  output: {
    dir: './api',
    imports: [
      'import axios from \'axios\'',
      'import type { AxiosResponse } from \'axios\''
    ],
    serviceTemplate: {
      classWrapper: (serviceName, methodsCode) => `
class ${serviceName}Service {
  private axiosInstance: any;

  constructor(baseURL: string = '') {
    this.axiosInstance = axios.create({ baseURL });
  }

${methodsCode}
}`,
      methodWrapper: (rpc) => `
  async ${rpc.name}(request: Types.${rpc.request}): Promise<Types.${rpc.resp}> {
    const { path, method } = rpc;
    const response = await this.axiosInstance[method.toLowerCase()](path, request);
    return response.data;
  }`
    }
  }
})
```

### 3. Example Usage

Assuming you have a `.proto` file:

```protobuf
syntax = "proto3";

import "google/api/annotations.proto";

package example;

message GetUserRequest {
  string user_id = 1;
}

message User {
  string id = 1;
  string name = 2;
}

service UserService {
  rpc GetUser(GetUserRequest) returns (User) {
    option (google.api.http) = {
      get: "/v1/users/{user_id}"
    };
  }
}
```

After running `pb2ts gen`, it will generate TypeScript code similar to (using default fetch configuration):

```ts
// ./api/UserService/UserService.types.ts
/**
 * ⚠️ AUTO-GENERATED CODE - DO NOT EDIT
 *
 * This file is automatically generated from Protocol Buffer definitions.
 * Any manual changes will be overwritten on the next generation.
 *
 * Generated at: 2023-01-01T00:00:00.000Z
 */

export interface GetUserRequest {
  user_id: string;
}

export interface User {
  id: string;
  name: string;
}

// ./api/UserService/UserService.index.ts
/**
 * ⚠️ AUTO-GENERATED CODE - DO NOT EDIT
 *
 * This file is automatically generated from Protocol Buffer definitions.
 * Any manual changes will be overwritten on the next generation.
 *
 * Generated at: 2023-01-01T00:00:00.000Z
 */
import * as Types from './UserService.types';

export { Types };

/**
 * Service class for UserService
 */
export class UserServiceService {
  private baseUrl: string;

  constructor(baseUrl: string = '') {
    this.baseUrl = baseUrl;
  }

  async GetUser(request: Types.GetUserRequest): Promise<Types.User> {
    const response = await fetch(`${this.baseUrl}/v1/users/${request.user_id}`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`GetUser failed: ${response.statusText}`);
    }

    return response.json();
  }
}

export { UserServiceService };
```

**Note**: A `UserService.extensions.ts` file will also be generated for user custom extensions. This file will not be overwritten after the first generation.

## Configuration Options

### Proto Configuration

- `root`: Root directory for proto files (default: "./")
- `include`: Patterns to include (default: ["**/*.proto"])
- `exclude`: Patterns to exclude (default: ["node_modules", "dist"])

### Output Configuration

- `dir`: Output directory (default: "./api")
- `generationType`: Generation type ('service' or 'function', default: 'service')
- `imports`: Additional import statements
- `funcCalls`: Custom call templates for specific RPC methods
- `serviceTemplate`: Service class template configuration
  - `classWrapper`: Class wrapper function
  - `methodWrapper`: Method wrapper function
  - `extensionWrapper`: Extension file template
- `functionTemplate`: Function generation template configuration
  - `functionWrapper`: Function wrapper function

## Supported Protobuf Features

- Message Definitions
- Enum Definitions
- Nested Messages and Enums
- Map Types
- Repeated Fields
- `google.api.http` Annotations (GET, POST, PUT, DELETE, PATCH)
- Basic Type Mapping (int32, string, bool, bytes, etc.)
- Comment Preservation

## Project Architecture

### Tech Stack

- **Go Language Parser**: `go_pb_parser` - High-performance Protocol Buffer parser
- **TypeScript Generator**: `packages/pb2ts` - Code generation and CLI tool
- **Build Tools**: pnpm, tsup
- **Command Line Framework**: cac

### Project Structure

```
pb2ts/
├── go_pb_parser/              # Go language parser
│   ├── cmd/                   # Command line entry point
│   ├── internal/
│   │   ├── parser/           # Core parsing logic
│   │   └── types/            # Type definitions
│   └── test_proto/           # Test proto files
├── packages/pb2ts/            # TypeScript package
│   ├── src/
│   │   ├── cli/              # Command-line interface
│   │   ├── config/           # Configuration system
│   │   ├── generator/        # Code generator
│   │   └── parser/           # Parser interfaces
├── bin/                      # Compiled binary files
├── scripts/                  # Build scripts
└── test/                     # Test files
```

### Go Parser

The Go parser is responsible for parsing `.proto` files and extracting service definitions, messages, enums, and other information. It uses the `github.com/jhump/protoreflect` library to handle complex Protocol Buffer files and generates JSON-formatted parsing results for the TypeScript code generator to use.

### TypeScript Generator

The TypeScript generator receives data from the Go parser and generates corresponding TypeScript code according to the configuration. It supports two generation modes:
- **Service Mode**: Generates service classes with static methods
- **Function Mode**: Generates standalone functions

## Development

### Prerequisites

- Node.js >= 18
- pnpm
- Go >= 1.19

### Building

```bash
# Install dependencies
pnpm install

# Build Go parser
go build -o bin/pb2ts-parser ./go_pb_parser/cmd/main.go

# Build TypeScript package
pnpm run build

# Development mode
pnpm run dev
```

### Testing

```bash
# Run Go unit tests
cd go_pb_parser && go test ./...

# Run code generation tests
pnpm run test:gen
```

### Contributing

We welcome community contributions! Please follow these steps:

1. Fork the project
2. Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## Frequently Asked Questions

### Q: How do I customize the generated code templates?

A: Customize code templates by defining `serviceTemplate` or `functionTemplate` in the configuration file.

### Q: Which HTTP methods are supported?

A: Supports all `google.api.http` annotated methods including GET, POST, PUT, DELETE, PATCH.

### Q: How are nested message types handled?

A: The generator automatically handles nested message types and properly declares them in the type files.

## License

MulanPSL2 (Mulan Permissive Software License v2)