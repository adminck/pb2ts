# pb2ts

`pb2ts` is a powerful tool that converts Protocol Buffer (protobuf) definition files into TypeScript HTTP client code. It's especially suitable for gRPC services that use `google.api.http` annotations to define RESTful APIs.

## Features

- **Automatic Code Generation**: Convert `.proto` files into TypeScript client code automatically
- **HTTP Annotation Support**: Parse `google.api.http` annotations to generate corresponding HTTP request code
- **Type Safety**: Generated TypeScript code includes complete type definitions
- **Dual Modes**: Choose between generating service classes or pure functions
- **Highly Configurable**: Supports custom templates and output options
- **Support for Nested Messages and Enums**: Fully handles complex protobuf structures
- **Complete Protobuf Type Mapping**: Supports basic types, messages, enums, Map types, and repeated fields
- **Comment Preservation**: Preserves comment information from original proto files
- **Go Language Parser**: Uses high-performance Go language parser to process proto files

## Installation

```bash
npm install pb2ts
```

## Quick Start

### 1. Basic Usage

```bash
# Use CLI to generate TypeScript code
npx pb2ts gen --proto ./proto --out ./src/api
```

### 2. Configuration File

Create a `pb2ts.config.ts` configuration file:

```ts
import { defineConfig } from 'pb2ts'

export default defineConfig({
  proto: {
    root: './proto',
    include: ['**/*.proto'],
    exclude: ['node_modules', 'dist']
  },
  output: {
    dir: './src/api',
    generationType: 'service', // 'service' or 'function'
    imports: [
      'import axios from \'axios\'',
      'import type { AxiosResponse } from \'axios\''
    ],
    serviceTemplate: {
      classWrapper: (serviceName, methodsCode) => `
class ${serviceName} {
  ${methodsCode}
}`,
      methodWrapper: (rpc) => `
  static async ${rpc.name}(req: Types.${rpc.Request}): Promise<Types.${rpc.Resp}> {
    const response = await axios.${rpc.method.toLowerCase()}('${rpc.Path}', req);
    return response.data;
  }`
    }
  }
})
```

### 3. Example Usage

Assuming you have a `.proto` file:

```protobuf
syntax = "proto3";

import "google/api/annotations.proto";

package example;

message GetUserRequest {
  string user_id = 1;
}

message User {
  string id = 1;
  string name = 2;
}

service UserService {
  rpc GetUser(GetUserRequest) returns (User) {
    option (google.api.http) = {
      get: "/v1/users/{user_id}"
    };
  }
}
```

After running `pb2ts gen`, it will generate TypeScript code similar to:

```ts
// ./src/api/UserService/UserService.types.ts
/**
 * ⚠️ AUTO-GENERATED CODE - DO NOT EDIT
 * 
 * This file is automatically generated from Protocol Buffer definitions.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Generated at: 2023-01-01T00:00:00.000Z
 */

export interface GetUserRequest {
  user_id: string;
}

export interface User {
  id: string;
  name: string;
}

// ./src/api/UserService/UserService.index.ts
/**
 * ⚠️ AUTO-GENERATED CODE - DO NOT EDIT
 * 
 * This file is automatically generated from Protocol Buffer definitions.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Generated at: 2023-01-01T00:00:00.000Z
 */
import * as Types from './UserService.types';
import axios from 'axios';
import type { AxiosResponse } from 'axios';

export { Types };

class UserService {
  static async GetUser(req: Types.GetUserRequest): Promise<Types.User> {
    const response = await axios.get(`/v1/users/${req.user_id}`);
    return response.data;
  }
}

export { UserService };
```

## Configuration Options

### Proto Configuration

- `root`: Root directory for proto files (default: "proto")
- `include`: Patterns to include (default: ["**/*.proto"])
- `exclude`: Patterns to exclude (default: ["node_modules", "dist"])

### Output Configuration

- `dir`: Output directory (default: "src/api")
- `generationType`: Generation type ('service' or 'function', default: 'service')
- `imports`: Additional import statements
- `funcCalls`: Custom call templates for specific RPC methods
- `serviceTemplate`: Service class template configuration
  - `classWrapper`: Class wrapper function
  - `methodWrapper`: Method wrapper function
  - `extensionWrapper`: Extension file template
- `functionTemplate`: Function generation template configuration
  - `functionWrapper`: Function wrapper function

## Supported Protobuf Features

- Message Definitions
- Enum Definitions
- Nested Messages and Enums
- Map Types
- Repeated Fields
- `google.api.http` Annotations (GET, POST, PUT, DELETE, PATCH)
- Basic Type Mapping (int32, string, bool, bytes, etc.)
- Comment Preservation

## Project Architecture

### Tech Stack

- **Go Language Parser**: `go_pb_parser` - High-performance Protocol Buffer parser
- **TypeScript Generator**: `packages/pb2ts` - Code generation and CLI tool
- **Build Tools**: pnpm, tsup
- **Command Line Framework**: cac

### Project Structure

```
pb2ts/
├── go_pb_parser/              # Go language parser
│   ├── cmd/                   # Command line entry point
│   ├── internal/
│   │   ├── parser/           # Core parsing logic
│   │   └── types/            # Type definitions
│   └── test_proto/           # Test proto files
├── packages/pb2ts/            # TypeScript package
│   ├── src/
│   │   ├── cli/              # Command-line interface
│   │   ├── config/           # Configuration system
│   │   ├── generator/        # Code generator
│   │   └── parser/           # Parser interfaces
├── bin/                      # Compiled binary files
├── scripts/                  # Build scripts
└── test/                     # Test files
```

### Go Parser

The Go parser is responsible for parsing `.proto` files and extracting service definitions, messages, enums, and other information. It uses the `github.com/jhump/protoreflect` library to handle complex Protocol Buffer files and generates JSON-formatted parsing results for the TypeScript code generator to use.

### TypeScript Generator

The TypeScript generator receives data from the Go parser and generates corresponding TypeScript code according to the configuration. It supports two generation modes:
- **Service Mode**: Generates service classes with static methods
- **Function Mode**: Generates standalone functions

## Development

### Prerequisites

- Node.js >= 18
- pnpm
- Go >= 1.19

### Building

```bash
# Install dependencies
pnpm install

# Build Go parser
go build -o bin/pb2ts-parser ./go_pb_parser/cmd/main.go

# Build TypeScript package
pnpm run build

# Development mode
pnpm run dev
```

### Testing

```bash
# Run Go unit tests
cd go_pb_parser && go test ./...

# Run code generation tests
pnpm run test:gen
```

### Contributing

We welcome community contributions! Please follow these steps:

1. Fork the project
2. Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## Frequently Asked Questions

### Q: How do I customize the generated code templates?

A: Customize code templates by defining `serviceTemplate` or `functionTemplate` in the configuration file.

### Q: Which HTTP methods are supported?

A: Supports all `google.api.http` annotated methods including GET, POST, PUT, DELETE, PATCH.

### Q: How are nested message types handled?

A: The generator automatically handles nested message types and properly declares them in the type files.

## License

MIT License